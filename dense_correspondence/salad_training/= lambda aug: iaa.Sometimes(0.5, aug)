[0;31mInit signature:[0m [0miaa[0m[0;34m.[0m[0mAffine[0m[0;34m([0m[0mself[0m[0;34m,[0m [0mscale[0m[0;34m=[0m[0;36m1.0[0m[0;34m,[0m [0mtranslate_percent[0m[0;34m=[0m[0mNone[0m[0;34m,[0m [0mtranslate_px[0m[0;34m=[0m[0mNone[0m[0;34m,[0m [0mrotate[0m[0;34m=[0m[0;36m0.0[0m[0;34m,[0m [0mshear[0m[0;34m=[0m[0;36m0.0[0m[0;34m,[0m [0morder[0m[0;34m=[0m[0;36m1[0m[0;34m,[0m [0mcval[0m[0;34m=[0m[0;36m0[0m[0;34m,[0m [0mmode[0m[0;34m=[0m[0;34m'constant'[0m[0;34m,[0m [0mbackend[0m[0;34m=[0m[0;34m'auto'[0m[0;34m,[0m [0mname[0m[0;34m=[0m[0mNone[0m[0;34m,[0m [0mdeterministic[0m[0;34m=[0m[0mFalse[0m[0;34m,[0m [0mrandom_state[0m[0;34m=[0m[0mNone[0m[0;34m)[0m[0;34m[0m[0m
[0;31mDocstring:[0m     
Augmenter to apply affine transformations to images.

This is mostly a wrapper around skimage's AffineTransform class and
warp function.

Affine transformations
involve:
    - Translation ("move" image on the x-/y-axis)
    - Rotation
    - Scaling ("zoom" in/out)
    - Shear (move one side of the image, turning a square into a trapezoid)

All such transformations can create "new" pixels in the image without a
defined content, e.g. if the image is translated to the left, pixels
are created on the right.
A method has to be defined to deal with these pixel values. The
parameters `cval` and `mode` of this class deal with this.

Some transformations involve interpolations between several pixels
of the input image to generate output pixel values. The parameter `order`
deals with the method of interpolation used for this.

Parameters
----------
scale : float or tuple of two floats or StochasticParameter or dict {"x": float/tuple/StochasticParameter, "y": float/tuple/StochasticParameter}, optional(default=1.0)
    Scaling factor to use, where 1.0 represents no change and 0.5 is
    zoomed out to 50 percent of the original size.
        * If a single float, then that value will be used for all images.
        * If a tuple (a, b), then a value will be sampled from the range
          a <= x <= b per image. That value will be used identically for
          both x- and y-axis.
        * If a StochasticParameter, then from that parameter a value will
          be sampled per image (again, used for both x- and y-axis).
        * If a dictionary, then it is expected to have the keys "x" and/or "y".
          Each of these keys can have the same values as described before
          for this whole parameter (`scale`). Using a dictionary allows to
          set different values for the axis. If they are set to the same
          ranges, different values may still be sampled per axis.

translate_percent : float or tuple of two floats or StochasticParameter or dict {"x": float/tuple/StochasticParameter, "y": float/tuple/StochasticParameter}, optional(default=1.0)
    Translation in percent relative to the image
    height/width (x-translation, y-translation) to use,
    where 0 represents no change and 0.5 is half of the image
    height/width.
        * If a single float, then that value will be used for all images.
        * If a tuple (a, b), then a value will be sampled from the range
          a <= x <= b per image. That percent value will be used identically
          for both x- and y-axis.
        * If a StochasticParameter, then from that parameter a value will
          be sampled per image (again, used for both x- and y-axis).
        * If a dictionary, then it is expected to have the keys "x" and/or "y".
          Each of these keys can have the same values as described before
          for this whole parameter (`translate_percent`).
          Using a dictionary allows to set different values for the axis.
          If they are set to the same ranges, different values may still
          be sampled per axis.

translate_px : int or tuple of two ints or StochasticParameter or dict {"x": int/tuple/StochasticParameter, "y": int/tuple/StochasticParameter}, optional(default=1.0)
    Translation in
    pixels.
        * If a single int, then that value will be used for all images.
        * If a tuple (a, b), then a value will be sampled from the discrete
          range [a .. b] per image. That number will be used identically
          for both x- and y-axis.
        * If a StochasticParameter, then from that parameter a value will
          be sampled per image (again, used for both x- and y-axis).
        * If a dictionary, then it is expected to have the keys "x" and/or "y".
          Each of these keys can have the same values as described before
          for this whole parameter (`translate_px`).
          Using a dictionary allows to set different values for the axis.
          If they are set to the same ranges, different values may still
          be sampled per axis.

rotate : float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)
    Rotation in degrees (NOT radians), i.e. expected value range is
    0 to 360 for positive rotations (may also be negative).
        * If a float/int, then that value will be used for all images.
        * If a tuple (a, b), then a value will be sampled per image from the
          range a <= x <= b and be used as the rotation value.
        * If a StochasticParameter, then this parameter will be used to
          sample the rotation value per image.

shear : float or int or tuple of two floats/ints or StochasticParameter, optional(default=0)
    Shear in degrees (NOT radians), i.e. expected value range is
    0 to 360 for positive shear (may also be negative).
        * If a float/int, then that value will be used for all images.
        * If a tuple (a, b), then a value will be sampled per image from the
          range a <= x <= b and be used as the rotation value.
        * If a StochasticParameter, then this parameter will be used to
          sample the shear value per image.

order : int or iterable of int or ia.ALL or StochasticParameter, optional(default=1)
    Interpolation order to use. Same meaning as in
    skimage:
        * 0: Nearest-neighbor
        * 1: Bi-linear (default)
        * 2: Bi-quadratic (not recommended by skimage)
        * 3: Bi-cubic
        * 4: Bi-quartic
        * 5: Bi-quintic
    Method 0 and 1 are fast, 3 is a bit slower, 4 and 5 are very
    slow.
    If the backend is `cv2`, the mapping to opencv's interpolation modes
    is as follows:
        * 0 -> cv2.INTER_NEAREST
        * 1 -> cv2.INTER_LINEAR
        * 2 -> cv2.INTER_CUBIC
        * 3 -> cv2.INTER_CUBIC
        * 4 -> cv2.INTER_CUBIC
    As datatypes this parameter
    accepts:
        * If a single int, then that order will be used for all images.
        * If an iterable, then for each image a random value will be sampled
          from that iterable (i.e. list of allowed order values).
        * If ia.ALL, then equivalant to list [0, 1, 3, 4, 5].
        * If StochasticParameter, then that parameter is queried per image
          to sample the order value to use.

cval : number or tuple of two number or ia.ALL or StochasticParameter, optional(default=0)
    The constant value used for skimage's transform function.
    This is the value used to fill up pixels in the result image that
    didn't exist in the input image (e.g. when translating to the left,
    some new pixels are created at the right). Such a fill-up with a
    constant value only happens, when `mode` is "constant".
    For standard uint8 images (value range 0-255), this value may also
    come from the range 0-255. It may be a float value, even for
    integer image dtypes.
        * If this is a single int or float, then that value will be used
          (e.g. 0 results in black pixels).
        * If a tuple (a, b), then a random value from the range a <= x <= b
          is picked per image.
        * If ia.ALL, a value from the discrete range [0 .. 255] will be
          sampled per image.
        * If a StochasticParameter, a new value will be sampled from the
          parameter per image.

mode : string or list of string or ia.ALL or StochasticParameter, optional(default="constant")
    Parameter that defines the handling of newly created pixels.
    Same meaning as in skimage (and numpy.pad):
        * "constant": Pads with a constant value
        * "edge": Pads with the edge values of array
        * "symmetric": Pads with the reflection of the vector mirrored
          along the edge of the array.
        * "reflect": Pads with the reflection of the vector mirrored on
          the first and last values of the vector along each axis.
        * "wrap": Pads with the wrap of the vector along the axis.
          The first values are used to pad the end and the end values
          are used to pad the beginning.
    If `cv2` is chosen as the backend the mapping is as
    follows:
        * "constant" -> cv2.BORDER_CONSTANT
        * "edge" -> cv2.BORDER_REPLICATE
        * "symmetric" -> cv2.BORDER_REFLECT
        * "reflect" -> cv2.BORDER_REFLECT_101
        * "wrap" -> cv2.BORDER_WRAP
    The datatype of the parameter may
    be:
        * If a single string, then that mode will be used for all images.
        * If a list of strings, then per image a random mode will be picked
          from that list.
        * If ia.ALL, then a random mode from all possible modes will be
          picked.
        * If StochasticParameter, then the mode will be sampled from that
          parameter per image, i.e. it must return only the above mentioned
          strings.

backend : string, optional(default="auto")
    Framework to use as a backend. Valid values are `auto`, `skimage`
    (scikit-image's warp) and `cv2` (opencv's warp).
    If `auto` is used, the augmenter will automatically try
    to use cv2 where possible (order must be in [0, 1, 3] and
    image's dtype uint8, otherwise skimage is chosen). It will
    silently fall back to skimage if order/dtype is not supported by cv2.
    cv2 is generally faster than skimage. It also supports RGB cvals,
    while skimage will resort to intensity cvals (i.e. 3x the same value
    as RGB). If `cv2` is chosen and order is 2 or 4, it will automatically
    fall back to order 3.

name : string, optional(default=None)
    See `Augmenter.__init__()`

deterministic : bool, optional(default=False)
    See `Augmenter.__init__()`

random_state : int or np.random.RandomState or None, optional(default=None)
    See `Augmenter.__init__()`

Examples
--------
>>> aug = iaa.Affine(scale=2.0)

zooms all images by a factor of 2.

>>> aug = iaa.Affine(translate_px=16)

translates all images on the x- and y-axis by 16 pixels (to the
right/top), fills up any new pixels with zero (black values).

>>> aug = iaa.Affine(translate_percent=0.1)

translates all images on the x- and y-axis by 10 percent of their
width/height (to the right/top), fills up any new pixels with zero
(black values).

>>> aug = iaa.Affine(rotate=35)

rotates all images by 35 degrees, fills up any new pixels with zero
(black values).

>>> aug = iaa.Affine(shear=15)

rotates all images by 15 degrees, fills up any new pixels with zero
(black values).

>>> aug = iaa.Affine(translate_px=(-16, 16))

translates all images on the x- and y-axis by a random value
between -16 and 16 pixels (to the right/top) (same for both axis, i.e.
sampled once per image), fills up any new pixels with zero (black values).

>>> aug = iaa.Affine(translate_px={"x": (-16, 16), "y": (-4, 4)})

translates all images on the x-axis by a random value
between -16 and 16 pixels (to the right) and on the y-axis by a
random value between -4 and 4 pixels to the top. Even if both ranges
were the same, both axis could use different samples.
Fills up any new pixels with zero (black values).

>>> aug = iaa.Affine(scale=2.0, order=[0, 1])

same as previously, but uses (randomly) either nearest neighbour
interpolation or linear interpolation.

>>> aug = iaa.Affine(translate_px=16, cval=(0, 255))

same as previously, but fills up any new pixels with a random
brightness (same for the whole image).

>>> aug = iaa.Affine(translate_px=16, mode=["constant", "edge"])

same as previously, but fills up the new pixels in only 50 percent
of all images with black values. In the other 50 percent of all cases,
the value of the nearest edge is used.
[0;31mFile:[0m           ~/virtualenvs/pci_venv/local/lib/python2.7/site-packages/imgaug/augmenters/geometric.py
[0;31mType:[0m           ABCMeta
